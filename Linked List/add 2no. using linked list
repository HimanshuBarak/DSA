Given two numbers represented by two linked lists of size N and M. The task is to return a sum list.

The sum list is a linked list representation of the addition of two input numbers from the last.

Example 1:

Input:
N = 2
valueN[] = {4,5}
M = 3
valueM[] = {3,4,5}
Output: 3 9 0  
Explanation: For the given two linked
list (4 5) and (3 4 5), after adding
the two linked list resultant linked
list will be (3 9 0).
Example 2:

Input:
N = 2
valueN[] = {6,3}
M = 1
valueM[] = {7}
Output: 7 0
Explanation: For the given two linked
list (6 3) and (7), after adding the
two linked list resultant linked list
will be (7 0).
Your Task:
The task is to complete the function addTwoLists() which has node reference of both the linked lists and returns the head of the sum list.   

Expected Time Complexity: O(N+M)
Expected Auxiliary Space: O(Max(N,M)) for the resultant list.

Constraints:
1 <= N, M <= 5000


/////////////////////////////////Solution/////////////////////////////////
class Solution
{
    public:
     Node* reverselist(Node* head)
{
    Node* prev= NULL;
    Node* curr=head;
    Node* next =NULL;

    while(curr!=NULL)
    {
        next = curr->next;
        curr->next = prev;
        prev=curr;
        curr=next;
    }
    head=prev;
    return head;
}
   Node* push_back(int newElement,Node* head) {
      Node* newNode = new Node(newElement);
     
      if(head == NULL) {
        head = newNode;
      } else {
        Node* temp = head;
        while(temp->next != NULL)
          temp = temp->next;
        temp->next = newNode;
      } 
      return head;
    }
    //Function to add two numbers represented by linked list.
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // code here
        
        Node* t1=first;Node* t2=second; Node* lg=NULL;Node* sm=NULL;
        
        int c1=0,c2=0;
        while(t1!=NULL)
        {
            c1++;
            t1=t1->next;
        }
        while(t2!=NULL)
        {
            c2++;
            t2=t2->next;
        }
        if(c1>c2)
        {
            lg=first;
            sm=second;
        }
        else{
            sm=first;
            lg=second;
        }
        
        //reversing the lists
        lg=reverselist(lg);
        sm=reverselist(sm);

        int carry=0;
        Node* sumhead=NULL;
        //the meat of the question
        while(lg!=NULL)
        {   int k=0;
            if(sm==NULL)
               k = lg->data + carry;
            else
              k=lg->data+sm->data+carry; 
            
            if(k>=10)
            {   
                sumhead=push_back(k%10,sumhead);
                carry=k/10;
            }
           
            else
            {
                sumhead=push_back(k,sumhead);
                carry=0;
               
            }
            if(sm)
            sm=sm->next;
            lg=lg->next;
            
        }
        //adding that additional node if required
        if(carry!=0)
        {
            sumhead=push_back(carry,sumhead);
            
        }
        sumhead=reverselist(sumhead);
        
        return sumhead;
    }
};
